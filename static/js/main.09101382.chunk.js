(this.webpackJsonpchairs=this.webpackJsonpchairs||[]).push([[0],{60:function(e,t,n){},67:function(e,t,n){"use strict";n.r(t);var r=n(47),o=n.n(r),i=n(2),a=(n(60),n(8)),c=n(19),u=n(11),s=n(13),l=n(1),d=n(33),m=n(51),b=n(72),v=n(69),x=n(70),f=n(71),g=n(68),O=n(12),E=Object(g.a)({texture1:null,texture2:null,shownTxt:-1,resolution:new l.Vector2},"\n  void main() {\n    gl_Position = vec4(position,1.0);\n  }\n  ",'\n  #ifdef FXAA\n    /**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it\'s\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent \n//texture reads can be a bottleneck\nvec4 fxaa_403044279(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n//To save 9 dependent texture reads, you can compute\n//these in the vertex shader and use the optimized\n//frag.glsl function in your frag shader. \n\n//This is best suited for mobile devices, like iOS.\n\nvoid texcoords_1177218260(vec2 fragCoord, vec2 resolution,\n\t\t\tout vec2 v_rgbNW, out vec2 v_rgbNE,\n\t\t\tout vec2 v_rgbSW, out vec2 v_rgbSE,\n\t\t\tout vec2 v_rgbM) {\n\tvec2 inverseVP = 1.0 / resolution.xy;\n\tv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n\tv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n\tv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n\tv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n\tv_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution) {\n\tmediump vec2 v_rgbNW;\n\tmediump vec2 v_rgbNE;\n\tmediump vec2 v_rgbSW;\n\tmediump vec2 v_rgbSE;\n\tmediump vec2 v_rgbM;\n\n\t//compute the texture coords\n\ttexcoords_1177218260(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\t\n\t//compute FXAA\n\treturn fxaa_403044279(tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n\n  #endif\n\n  varying vec2 v_texCoord0;\n  \n  uniform vec2 resolution;\n  uniform sampler2D texture1;\n  uniform sampler2D texture2;\n  uniform float shownTxt;\n\n  void main() {\n    \n    #ifdef FXAA\n      vec4 _texture1 = fxaa(texture1, gl_FragCoord.xy, resolution);\n      vec4 _texture2 = fxaa(texture2, gl_FragCoord.xy, resolution);\n    #else\n      vec2 uv = gl_FragCoord.xy / resolution;\n      vec4 _texture1 = texture2D(texture1, uv);\n      vec4 _texture2 = texture2D(texture2, uv);\n    #endif\n\n    float opacity = shownTxt < 0. ? 1. + shownTxt : 1.;\n    float _shownTxt = shownTxt < 0. ? 0. : shownTxt;\n\n    vec4 finalTexture = mix(_texture1, _texture2, _shownTxt);\n    finalTexture =  vec4(finalTexture.rgb, opacity * finalTexture.a);\n    gl_FragColor = finalTexture;\n  }\n');function A(e){var t=e.shownTxt,n=Object(c.a)(e,["shownTxt"]),r=Object(i.useRef)(),o=Object(s.i)(),u=o.size,d=o.gl,m=Object(i.useMemo)((function(){return d.getPixelRatio()}),[d]);return Object(s.g)((function(){return r.current.shownTxt=l.MathUtils.lerp(r.current.shownTxt,t,.2)})),Object(O.jsx)("xFadeMaterial",Object(a.a)(Object(a.a)({ref:r},n),{},{resolution:[u.width*m,u.height*m],defines:{FXAA:!d.capabilities.isWebGL2}}))}Object(s.e)({XFadeMaterial:E});var S={from:{rotation:[0,-Math.PI/10,0],scale:[.8,.8,.8]},enter:{rotation:[0,0,0],scale:[1,1,1]},leave:{rotation:[0,Math.PI/10,0],scale:[.8,.8,.8]}};function N(e){var t=e.model,n=Object(c.a)(e,["model"]),r=Object(i.useRef)(),o=Object(i.useMemo)((function(){return[new l.Euler,new l.Quaternion]}),[]),d=Object(u.a)(o,2),b=d[0],v=d[1];return Object(s.g)((function(e){r.current&&(b.set(0,e.mouse.x*Math.PI/150,-e.mouse.y*Math.PI/150),r.current.quaternion.slerp(v.setFromEuler(b),.1))})),Object(O.jsxs)("group",{ref:r,children:[Object(O.jsx)("pointLight",{intensity:.6,position:[4,6,-1],decay:3,rotation:[2,1,-2]}),Object(O.jsx)(m.a.primitive,Object(a.a)(Object(a.a)({},n),{},{object:t.scene}))]})}function h(e){var t=e.target,n=e.model,r=e.camRef,o=Object(c.a)(e,["target","model","camRef"]),u=Object(i.useMemo)((function(){return new l.Scene}),[]);return Object(s.g)((function(e){e.gl.setRenderTarget(t),e.gl.render(u,r.current)}),0),Object(s.d)(Object(O.jsx)(N,Object(a.a)({model:n},o)),u)}function T(e){var t=e.modelIndex,n=void 0===t?0:t,r=Object(b.a)(["./stool.glb","./table.glb","./bench.glb"]),o=Object(i.useState)([n,1]),c=Object(u.a)(o,1)[0],l=Object(i.useRef)(1),m=Object(i.useMemo)((function(){c.indexOf(n)<0&&(c[l.current]=n);var e=c.indexOf(n);return l.current=e?0:1,e}),[n,c]),g=Object(v.a)({stencilBuffer:!1,multisample:!0}),E=Object(v.a)({stencilBuffer:!1,multisample:!0}),N=[g,E],T=Object(i.useRef)();Object(s.g)((function(e){e.gl.setRenderTarget(null),e.gl.render(e.scene,e.camera)}),1);var j=Object(d.useTransition)(m,Object(a.a)({expires:!1},S));return Object(O.jsxs)(O.Fragment,{children:[Object(O.jsx)(x.a,{ref:T,position:[-2.5,1.5,2],rotation:[-.5,-1,-.4],far:12,fov:38}),Object(O.jsx)(f.a,{children:Object(O.jsx)(A,{attach:"material",texture1:g.texture,texture2:E.texture,shownTxt:m})}),j((function(e,t){return Object(O.jsx)(h,Object(a.a)({target:N[t],model:r[c[t]],camRef:T},e))}))]})}function j(e){var t=e.models,n=e.modelIndex;return Object(O.jsx)(i.Suspense,{fallback:null,children:Object(O.jsx)(T,{models:t,modelIndex:n})})}var _={position:"fixed"},I=["Stool","Table","Bench"],R=I.map((function(e){return"./"+e.toLowerCase()+".glb"})),p="Lamp base. Stool. Outside table. Dish drainer. Closet door. Table. Square stool. Clothes rack. Bench. Bird feeder. Shelf. Handeplane surfing. Marking knife. Cutting board. Watch display".split(". "),C=function(e){var t=e.text,n=e.onHover,r=e.index,o=e.active,a=Object(i.useMemo)((function(){return I.indexOf(t)}),[t])>-1;return Object(O.jsx)("span",{className:o?"active":a?"":"item",onPointerEnter:function(){return a&&n(r)},children:t+"."})};function M(){var e=Object(i.useState)({}),t=Object(u.a)(e,2),n=t[0],r=(n.onGotPointerCaptureLegacy,Object(c.a)(n,["onGotPointerCaptureLegacy"])),o=t[1],l=Object(i.useState)(1),d=Object(u.a)(l,2),m=d[0],b=d[1],v=I.indexOf(p[m]);return Object(O.jsxs)(O.Fragment,{children:[Object(O.jsx)(s.a,{concurrent:!0,pixelRatio:[1,2],onCreated:function(e){var t=e.events;return o(t)},style:_,children:Object(O.jsx)(j,{modelIndex:v,models:R})}),Object(O.jsx)("div",Object(a.a)(Object(a.a)({className:"container"},r),{},{children:p.map((function(e,t){return Object(O.jsx)(C,{text:e,active:t===m,index:t,onHover:b},t)}))}))]})}o.a.render(Object(O.jsx)(M,{}),document.getElementById("root"))}},[[67,1,2]]]);
//# sourceMappingURL=main.09101382.chunk.js.map